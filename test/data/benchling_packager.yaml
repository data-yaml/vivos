Description: Automatically create a dedicated Quilt package for every Benchling notebook
Outputs:
  TemplateBuildMetadata:
    Description: Metadata generated by the Quilt build system.
    Value: '{"git_revision": "7d8d222d99ac24e252df175c0e95980465c7fb4f", "git_repository": "/Users/quilt/Documents/GitHub/benchling-packager", "make_time": "2023-08-17 22:58:38.653425+00:00"}'
Parameters:
  BenchlingEventBusName:
    Type: String
    AllowedPattern: ^aws\.partner(/[\.\-_A-Za-z0-9]+){2,}$
    Description: Name of event bus where Benchling events are emitted, e.g aws.partner/benchling.com/tenant/app-name
  BenchlingTenant:
    Type: String
    AllowedPattern: ^[^/]+$
    Description: Benchling tenant name, i.e. $BenchlingTenant in https://$BenchlingTenant.benchling.com
  BenchlingClientId:
    Type: String
    MinLength: 1
    Description: Client ID of Benchling app
  QuiltWebHost:
    Type: String
    AllowedPattern: ^[^/]+$
    Description: Hostname for your Quilt catalog, e.g. quilt.your-company.com
  DestinationBucket:
    Type: String
    AllowedPattern: ^[\.\-a-z0-9]{3,63}$
    Description: The name of S3 bucket where packages will be created
  PackageNamePrefix:
    Type: String
    Default: benchling/
    AllowedPattern: .+/.*$
    Description: Prefix for package names i.e. package names will be $PackageNamePrefix$ExperimentDisplayID, must contain, but not start with '/'
Resources:
  Layer:
    Properties:
      Content:
        S3Bucket: !Sub 'quilt-lambda-${AWS::Region}'
        S3Key: benchling-packager/benchling-packager-layer.4bcb4369305e6dca4ec2cec50d2891ad138adfc1f3833293d32a999bd1295770.zip
    Type: AWS::Lambda::LayerVersion
  BenchlingClientSecret:
    Type: AWS::SecretsManager::Secret
  LambdaRole:
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: ''
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: secretsmanager:GetSecretValue
                Resource: !Ref 'BenchlingClientSecret'
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetObjectTagging
                  - s3:GetObjectVersion
                  - s3:GetObjectVersionTagging
                  - s3:ListBucket
                  - s3:ListBucketVersions
                  - s3:PutObject
                  - s3:PutObjectTagging
                Resource:
                  - !Sub 'arn:aws:s3:::${DestinationBucket}'
                  - !Sub 'arn:aws:s3:::${DestinationBucket}/*'
    Type: AWS::IAM::Role
  Lambda:
    Properties:
      Role: !GetAtt 'LambdaRole.Arn'
      Runtime: python3.9
      Timeout: 900
      Layers:
        - !Ref 'Layer'
      Environment:
        Variables:
          LOG_LEVEL: DEBUG
          POWERTOOLS_LOGGER_LOG_EVENT: '1'
          BENCHLING_TENANT: !Ref 'BenchlingTenant'
          BENCHLING_CLIENT_ID: !Ref 'BenchlingClientId'
          BENCHLING_CLIENT_SECRET_ARN: !Ref 'BenchlingClientSecret'
          DST_BUCKET: !Ref 'DestinationBucket'
          PKG_PREFIX: !Ref 'PackageNamePrefix'
          QUILT_CATALOG_DOMAIN: !Ref 'QuiltWebHost'
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          import io
          import json
          import os
          import pathlib
          import tempfile
          import zipfile
          from urllib import request as urllib_request

          import jinja2
          from aws_lambda_powertools import Logger
          from aws_lambda_powertools.utilities import parameters
          from benchling_sdk import models as benchling_models
          from benchling_sdk.auth.client_credentials_oauth2 import ClientCredentialsOAuth2
          from benchling_sdk.benchling import Benchling
          from benchling_sdk.helpers import serialization_helpers
          from botocore import exceptions as botocore_exceptions

          # Must be done before importing quilt3
          os.environ["QUILT_DISABLE_CACHE"] = "true"
          import quilt3  # noqa: E402

          logger = Logger()


          class BenchlingClient:
              BENCHLING_TENANT = os.environ["BENCHLING_TENANT"]
              BENCHLING_CLIENT_ID = os.environ["BENCHLING_CLIENT_ID"]
              BENCHLING_CLIENT_SECRET_ARN = os.environ["BENCHLING_CLIENT_SECRET_ARN"]

              @classmethod
              def Default(cls):
                  return cls(
                      cls.BENCHLING_TENANT,
                      cls.BENCHLING_CLIENT_ID,
                      cls.BENCHLING_CLIENT_SECRET_ARN,
                  )

              def __init__(self, tenant, id, arn):
                  if not isinstance(arn, str):
                      raise Exception("Failed to fetch CLIENT_SECRET_ARN")
                  secret = parameters.get_secret(arn)
                  if not isinstance(secret, str):
                      raise Exception(f"Failed to fetch secret: {arn!r}")
                  self.benchling = Benchling(
                      url=f"https://{tenant}.benchling.com",
                      auth_method=ClientCredentialsOAuth2(
                          client_id=id,
                          client_secret=secret,
                      ),
                  )

              def get_task(self, entry_id):
                  self.task = self.benchling.tasks.wait_for_task(
                      self.benchling.exports.export(
                          benchling_models.ExportItemRequest(id=entry_id)  # type: ignore
                      ).task_id
                  )
                  if self.task.status != benchling_models.AsyncTaskStatus.SUCCEEDED:
                      raise Exception(f"Notes export failed: {self.task!r}")
                  return self.task

              def update_entry(self, entry_id, fields_values):
                  values = {k: {"value": v} for k, v in fields_values.items()}
                  fields = serialization_helpers.fields(values)
                  self.benchling.entries.update_entry(
                      entry_id,
                      benchling_models.EntryUpdate(fields=fields),  # type: ignore
                  )


          class BenchlingEntry:
              REVISE = "action=revisePackage"

              QUILT_SUMMARIZE = json.dumps(
                  [
                      [
                          {
                              "path": "entry.md",
                              "width": "calc(40% - 16px)",
                              "expand": True,
                          },
                          {
                              "path": "notes.pdf",
                              "width": "calc(60% - 16px)",
                              "expand": True,
                          },
                      ]
                  ]
              )

              FLD = {
                  "URI": "Quilt+ URI",
                  "CAT": "Quilt Catalog URL",
                  "REV": "Quilt Revise URL",
              }

              ENTRY_FMT = """
          # [{{ entry.name }}]({{ entry.webURL }})

          * id: {{ entry.id }}
          * displayId: {{ entry.displayId }}
          * folderId: {{ entry.folderId }}
          * createdAt: {{ entry.createdAt }}
          * modifiedAt: {{ entry.modifiedAt }}

          ## Authors
          {% for author in entry.authors %}
          * {{ author.name }}
            * id: {{ author.id }}
            * handle: {{ author.handle }}
          {%- endfor %}

          ## Schema

          * id: {{ entry.schema.id }}
          * name: {{ entry.schema.name }}

          ## Fields
          {% for name, value in entry.fields.items() %}
          * {{ name }}: {{ value.displayValue }}
          {%- endfor %}

          ## Custom fields
          {% for name, value in entry.customFields.items() %}
          * {{ name }}: {{ value.value }}
          {%- endfor %}
          """

              DST_BUCKET = os.environ["DST_BUCKET"]
              PKG_PREFIX = os.environ["PKG_PREFIX"]
              QUILT_CATALOG_DOMAIN = os.environ["QUILT_CATALOG_DOMAIN"]
              QUILT_PREFIX = f"https://{QUILT_CATALOG_DOMAIN}/b/{DST_BUCKET}/packages"

              def __init__(self, entry):
                  self.client = BenchlingClient.Default()
                  self.entry = entry
                  self.entry_id = entry["id"]
                  self.fields = entry.get("fields", {})
                  self.pkg_name = self.name()
                  self.registry = f"s3://{self.DST_BUCKET}"

              def name(self):
                  SEP = "/" if self.PKG_PREFIX[-1] != "/" else ""
                  return self.PKG_PREFIX + SEP + self.entry.get("displayId", self.entry_id)

              def format(self):
                  template = jinja2.Template(self.ENTRY_FMT)
                  return template.render({"entry": self.entry})

              def dump(self):
                  return json.dumps(self.entry)

              def write_notes(self, tmpdir_path):
                  outfile = tmpdir_path / "notes.pdf"
                  task = self.client.get_task(self.entry_id)

                  with urllib_request.urlopen(task.response["downloadURL"]) as src:
                      buf = io.BytesIO(src.read())

                  with zipfile.ZipFile(buf) as zip_file:
                      with zip_file.open(zip_file.namelist()[0]) as src:
                          with outfile.open("wb") as dst:
                              while data := src.read(4096):
                                  dst.write(data)
                  return outfile

              def write_files(self, tmpdir_path):
                  self.write_notes(tmpdir_path)
                  (tmpdir_path / "entry.md").write_text(self.format())
                  (tmpdir_path / "entry.json").write_text(self.dump())
                  (tmpdir_path / "quilt_summarize.json").write_text(self.QUILT_SUMMARIZE)

              def push_package(self, tmpdir_path):
                  pkg = quilt3.Package()
                  try:
                      pkg = quilt3.Package.browse(self.pkg_name, registry=self.registry)
                  except botocore_exceptions.ClientError as e:
                      # XXX: quilt3 should raise some specific exception
                      # when package doesn't exist.
                      if e.response["Error"]["Code"] not in ("NoSuchKey", "404"):
                          raise

                  pkg.set_dir(".", tmpdir_path, meta=self.entry)
                  # This shouldn't hit 1 MB limit on metadata,
                  # because max size of EventBridge is 256 KiB.
                  return pkg.push(self.pkg_name, registry=self.registry)

              def field_values(self):
                  values = {
                      "URI": f"quilt+s3://{self.DST_BUCKET}#package={self.pkg_name}",
                      "CAT": f"{self.QUILT_PREFIX}/{self.pkg_name}",
                      "REV": f"{self.QUILT_PREFIX}/{self.pkg_name}?{self.REVISE}",
                  }
                  return {f: values.get(k) for k, f in self.FLD.items()}

              def update_benchling_notebook(self) -> bool:
                  values = self.field_values()
                  if values:
                      self.client.update_entry(self.entry_id, values)
                      logger.debug(f"Updated entry {self.entry_id} with package {self.pkg_name}")
                      return True
                  else:
                      logger.warning(f"Quilt schema fields not found for entry {self.entry_id!r}")
                      return False


          def main(entry_dict):
              entry = BenchlingEntry(entry_dict)
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmpdir_path = pathlib.Path(tmpdir)

                  entry.write_files(tmpdir_path)
                  entry.push_package(tmpdir_path)
                  entry.update_benchling_notebook()
              return entry


          @logger.inject_lambda_context
          def lambda_handler(event, context):
              main(event["detail"]["entry"])

              return {
                  "statusCode": 200,
              }
      ReservedConcurrentExecutions: 1
      MemorySize: 512
    Type: AWS::Lambda::Function
  EventBusRule:
    Properties:
      EventBusName: !Ref 'BenchlingEventBusName'
      EventPattern:
        source:
          - !Ref 'BenchlingEventBusName'
        detail-type:
          - v2.entry.created
          - v2.entry.updated.fields
      Targets:
        - Id: Lambda
          Arn: !GetAtt 'Lambda.Arn'
    Type: AWS::Events::Rule
  LambdaPermission:
    Properties:
      FunctionName: !GetAtt 'Lambda.Arn'
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt 'EventBusRule.Arn'
    Type: AWS::Lambda::Permission
